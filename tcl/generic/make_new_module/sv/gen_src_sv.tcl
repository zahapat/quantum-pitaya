# This file generates a template of a HDL source file (VHDL)

puts $new_file_src ""
puts $new_file_src "    \/\/ ${name_file}.${suffix_file}: <brief description>"
puts $new_file_src "    \/\/ Engineer: $engineer_name"
puts $new_file_src "    \/\/ Email: $email_addr"
set clock_seconds [clock seconds]
set act_date [clock format $clock_seconds -format %D]
puts $new_file_src "    \/\/ Created: $act_date"
puts $new_file_src ""
puts $new_file_src ""
puts $new_file_src "    module ${name_file} ("
puts $new_file_src "            input  logic clk,"
puts $new_file_src "            input  logic rst,"
puts $new_file_src "            input  logic valid,"
puts $new_file_src "            input  logic \[3:0\] a,"
puts $new_file_src "            input  logic \[3:0\] b,"
puts $new_file_src "            output logic \[3:0\] c"
puts $new_file_src "        );"
puts $new_file_src ""
puts $new_file_src ""
puts $new_file_src "        // Sequential Flip-Flop logic: it can contain one and only one event control and no blocking timing controls"
puts $new_file_src "        always_ff @(posedge clk)"
puts $new_file_src "            if (rst)"
puts $new_file_src "                // Assign 0 to each bit in vactor 'c'"
puts $new_file_src "                c <= '{default:0};"
puts $new_file_src "            else"
puts $new_file_src "                if (valid)"
puts $new_file_src "                    c <= a + b;"
puts $new_file_src "        "
puts $new_file_src "    endmodule"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    \/\/ Summary of Synthesisable SystemVerilog: https://www.cl.cam.ac.uk/teaching/1112/ECAD+Arch/files/SystemVerilogCheatSheet.pdf"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    4’b1011 == 4’hb == 4’d11"
puts $new_file_src "    {2’b10,2’b11} == 4’b1011"
puts $new_file_src "    parameter foo = 42"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    ==? and !=? wildcard equality/inequality operators"
puts $new_file_src "    inside set membership operator"
puts $new_file_src "        if (data inside {\[0:255\]) ...                 // if data is between 0 to 255, inclusive "
puts $new_file_src "        if (data inside {3'b1?1}) ...                   // if data is 3'b101, 3'b111, 3'b1x1, or 3'b1z1"
puts $new_file_src "    <<, >> pack and unpack streaming operators "
puts $new_file_src "        a = { << { b }};                                // bit reverse – unpack bits of b and assign to a in reverse order"
puts $new_file_src "        c = { <<8{ d }};                                // byte reverse – unpack 8-bit chunks of d and assign in reverse order"
puts $new_file_src "    ++ and -- increment and decrement operators"
puts $new_file_src "    +=, -=, *=, /= … assignment operators"
puts $new_file_src "    "
puts $new_file_src "    <<"
puts $new_file_src "    >>"
puts $new_file_src "    =="
puts $new_file_src "    !="
puts $new_file_src "    <"
puts $new_file_src "    <="
puts $new_file_src "    >"
puts $new_file_src "    >="
puts $new_file_src "    $"
puts $new_file_src "    |"
puts $new_file_src "    ^"
puts $new_file_src "    ~"
puts $new_file_src "    &&"
puts $new_file_src "    ||"
puts $new_file_src "    !"
puts $new_file_src "    &a == a\[0] & a\[1] & a\[2]"
puts $new_file_src "    |a == a\[0] | a\[1] | a\[2]"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    (a == 3'd3) ? formula1 : formula0"
puts $new_file_src "    ((a == 3'd3) && formula1) "
puts $new_file_src "    || (a != 3'd3) && formula0)"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    casting operations"
puts $new_file_src "    <type>’(<expression>)         // cast expression to different data type"
puts $new_file_src "    <size>’(<expression>)         // casts expression to a vector size"
puts $new_file_src "        signed’(<expression>)     // casts expression to signed"
puts $new_file_src "        unsigned’(<expression>)   // casts expression to unsigned"
puts $new_file_src "    logic \[31:0] a, y;"
puts $new_file_src "    logic \[ 5:0] b;"
puts $new_file_src "    y = {a,a} >> b;                     // Rotate a by b number of times"
puts $new_file_src "    y = logic \[31:0]'({a,a} >> b);      // Cast the operation result to 32 bits so that the RHS and the LHS are the same size"
puts $new_file_src "    ADVANTAGE: Documents intent that a change in type, size or sign is intended"
puts $new_file_src "               Can eliminate size and type mismatch warnings"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    // Module port connections"
puts $new_file_src "    '.name' // connects a port to a net of the same name"
puts $new_file_src "    dff dff1 (.clk, .rst, .pre, .d(d\[0]), .q(q\[0]));"
puts $new_file_src "    '*'     // automatically connects all ports and nets with the same name"
puts $new_file_src "    dff dff1 (.*, .q(q\[0]), .d(d\[0]), .qb());"
puts $new_file_src "    ADVANTAGE: Reduce typing (and typos) when connecting design blocks"
puts $new_file_src "               Built-in checking prevents connection mismatches"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    // Vector fill literal value"
puts $new_file_src "    x’0 fills all bits on the left-hand side with 0"
puts $new_file_src "    x’1 fills all bits on the left-hand side with 1"
puts $new_file_src "    x’z fills all bits on the left-hand side with z"
puts $new_file_src "    x’x fills all bits on the left-hand side with x"
puts $new_file_src "    reg \[N-1:0] data_bus;"
puts $new_file_src "    data_bus = x’1  // Set all bits of data_bus to 1;"
puts $new_file_src "    // ADVANTAGE: Code will scale correctly when vector sizes change"
puts $new_file_src "    //            Don’t need to know obscure coding tricks such as replicate"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    // `begin_keywords' directive tells software tools which version of reserved keywords to use during compilation"
puts $new_file_src "    `begin_keywords 1800-2005"
puts $new_file_src "    module decoder (...);"
puts $new_file_src "        always_comb"
puts $new_file_src "            priority case (...);"
puts $new_file_src "            ..."
puts $new_file_src "    endmodule"
puts $new_file_src "    `end_keywords"
puts $new_file_src "    // ADVANTAGE: Ensures design code is reusable, past, present and future"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    wire \[3:0] w;           = Net type, e.g. Input ports must be a net type"
puts $new_file_src "    reg \[7:0] r;            = Output ports must be reg(if assigned from a procedural block=initial, always) or wire(assigned from continuous assignment/if driven by an instance of a module or primitive output); reg does not infer a 'register', but it looks like it does"
puts $new_file_src "    reg \[7:0] mem \[0:31]"
puts $new_file_src "    r\[5:2]"
puts $new_file_src "    module chip"
puts $new_file_src "        (input wire in1,"
puts $new_file_src "         input wire in2,"
puts $new_file_src "         output reg out1,"
puts $new_file_src "         output wire out2"
puts $new_file_src "        );"
puts $new_file_src "    logic                   = 4-state variable, replaces reg; To avoid thinking about where to put reg and wire, just declare logic! SystemVerilog inders a variable or a net based on context"
puts $new_file_src "    module chip"
puts $new_file_src "        (input logic in1,"
puts $new_file_src "         input logic in2,"
puts $new_file_src "         output logic out1,"
puts $new_file_src "         output logic out2"
puts $new_file_src "        );"
puts $new_file_src "    // 2-state types (NOT SO USEFUL IN RTL): Avoid them in synthesizable models - They can hide serious design bugs!"
puts $new_file_src "    enum                    = a variable with a specified set of legal values. enum defines variables or nets with a legal set of values; each value is represented by a label"
puts $new_file_src "    // Rules for enumerated types"
puts $new_file_src "    //    The label value must be the same size as the variable"
puts $new_file_src "    //    Can be assigned a label from the enumerated list"
puts $new_file_src "    //    Can be assigned the value of an identical enumerated variable"
puts $new_file_src "    //    All other assignments are illegal"
puts $new_file_src "    enum logic \[2:0] {WAIT=3’b001, LOAD=3’b010, READY=3’b100} state;"
puts $new_file_src "                            // Enumerated types can prevent inadvertent (and hard to debug) coding errors (example on next slide)"
puts $new_file_src "        enum logic \[2:0]"
puts $new_file_src "            {WAIT = 3'b001,"
puts $new_file_src "             LOAD = 3'b010,"
puts $new_file_src "             DONE = 3'b001}                             // bug #1 (found by compiler)"
puts $new_file_src "            state, next_state;"
puts $new_file_src "        enum logic \[1:0]                                // bug #2 (found by compiler)"
puts $new_file_src "            {READY = 3'b101,"
puts $new_file_src "             SET = 3'b010,"
puts $new_file_src "             GO = 3'b110}"
puts $new_file_src "            mode_control;"
puts $new_file_src "        always_ff @(posedge clk or negedge rstN)"
puts $new_file_src "            if (!resetN) state <= 0;                    // bug #3 (found by compiler)"
puts $new_file_src "            else         state <= next_state;"
puts $new_file_src "        always_comb // next state decoder"
puts $new_file_src "            case (state)"
puts $new_file_src "                WAIT : next_state = state + 1;          // bug #4 (found by compiler)"
puts $new_file_src "                LOAD : next_state = state + 1;          // bug #5 (found by compiler)"
puts $new_file_src "                DONE : next_state = state + 1;          // bug #6 (found by compiler)"
puts $new_file_src "            endcase"
puts $new_file_src "        always_comb // output decoder"
puts $new_file_src "            case (state)"
puts $new_file_src "                WAIT : mode_control = READY;"
puts $new_file_src "                LOAD : mode_control = SET;"
puts $new_file_src "                DONE : mode_control = DONE;             // bug #7 (found by compiler)"
puts $new_file_src "            endcase"
puts $new_file_src "    struct {                    // Structures bundle multiple variables together;  entire structure can be assigned a list of values + structure can copied to another structure of same type + structures can be passed through module ports"
puts $new_file_src "        logic \[ 7:0] opcode;"
puts $new_file_src "        logic \[31:0] data;"
puts $new_file_src "        logic status;"
puts $new_file_src "    } operation;"
puts $new_file_src "    operation = ’{8’h55, 1024, 1’b0};           // Assign entire structure"
puts $new_file_src "    operation.data = 32’hFEEDFACE;              // Assign to structure member"
puts $new_file_src "    // ADVANTAGES: Bundle related signals together under one name"
puts $new_file_src "    //             Reduce lines of RTL code substantially"
puts $new_file_src "    //             Reduce risk of declaration mismatches"
puts $new_file_src "    //             Can eliminate design errors often not found until late in a design"
puts $new_file_src "    //             cycle (inter-module mismatches, missed assignments, ...) "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    int                     = 32-bit 2-stat) variable (use with for-loops, replaces integer)"
puts $new_file_src "    bit                     = single bit 2-state variable"
puts $new_file_src "    bit                     = 8-bit 2-state variable"
puts $new_file_src "    shortint                = 16-bit 2-state variable"
puts $new_file_src "    longiint                = 64-bit 2-state variable"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    typedef                 = user-defined type"
puts $new_file_src "    typedef logic \[31:0] bus32_t;"
puts $new_file_src "    typedef enum \[7:0] {ADD, SUB, MULT, DIV, SHIFT, ROT, XOR, NOP} opcodes_t;"
puts $new_file_src "    typedef enum logic {FALSE, TRUE} boolean_t;"
puts $new_file_src "    typedef struct {"
puts $new_file_src "        opcodes_t opcode;"
puts $new_file_src "        bus32_t data;"
puts $new_file_src "        boolean_t status;"
puts $new_file_src "    } operation_t;"
puts $new_file_src "    module ALU (input operation_t operation,"
puts $new_file_src "        output bus32_t result);"
puts $new_file_src "        operation_t registered_op;"
puts $new_file_src "        ..."
puts $new_file_src "    endmodule"
puts $new_file_src "    // ADVANTAGE: Can define complex types once and use many times"
puts $new_file_src "    //            Ensures consistency throughout a module"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    package project_types;"
puts $new_file_src "        typedef  logic \[31:0]     bus32_t;"
puts $new_file_src "        typedef  enum \[7:0] {...} opcodes_t;"
puts $new_file_src "        typedef  struct {...}     operation_t;"
puts $new_file_src "        function automatic crc_gen ...;"
puts $new_file_src "    endpackage"
puts $new_file_src "    module ALU"
puts $new_file_src "        import project_types::*;"
puts $new_file_src "            (input operation_t operation,"
puts $new_file_src "             output bus32_t result);"
puts $new_file_src "        operation_t registered_op;"
puts $new_file_src "        ..."
puts $new_file_src "    endmodule"
puts $new_file_src "    // ADVANTAGE: Ensures consistency throughout a project (including verification)"
puts $new_file_src "    //            Reduces duplicate code"
puts $new_file_src "    //            Makes code easier to maintain and reuse than `include"
puts $new_file_src "    //            Controlled scope"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    logic \[3:0]\[7:0] b;                     // Packed array: a 32-bit vector with 4 8-bit subfieds"
puts $new_file_src "     b\[3]  b\[2]  b\[1]  b\[0]"
puts $new_file_src "    \[7:0] \[7:0] \[7:0] \[7:0]"
puts $new_file_src "    "
puts $new_file_src "    logic \[7:0] a1 \[0:1]\[0:3] b;            // Unpacked array: a 32-bit vector with 4 8-bit subfieds"
puts $new_file_src "    logic \[7:0] a2 \[2]\[4]"
puts $new_file_src "    a1 = '{'{7, 3, 0, 5}, '{default: '1}}   // Assign values to the entire array (at once!)     // DECLARATION of a constant = '{}"
puts $new_file_src "    a2 = a1;                                // Copy the entire array"
puts $new_file_src "    // ADVANTAGE: Manipulating entire data arrays substantially reduces lines of code"
puts $new_file_src "    "
puts $new_file_src "    package design_types;"
puts $new_file_src "        typedef struct {                                            // This structure bundles 54 variables together (including the array of 48 Payload variables)"
puts $new_file_src "            logic \[ 3:0] GFC;"
puts $new_file_src "            logic \[ 7:0] VPI;"
puts $new_file_src "            logic \[15:0] VCI;"
puts $new_file_src "            logic CLP;"
puts $new_file_src "            logic \[ 2:0] T;"
puts $new_file_src "            logic \[ 7:0] HEC;"
puts $new_file_src "            logic \[ 7:0] Payload \[48];"
puts $new_file_src "        } uni_t; // UNI cell definition"
puts $new_file_src "    endpackage"
puts $new_file_src "    module transmit_reg (output design_types::uni_t data_reg,"
puts $new_file_src "                         input  design_types::uni_t data_packet,"
puts $new_file_src "                         input  logic               clock, resetN);"
puts $new_file_src "        always @(posedge clock or negedge resetN)"
puts $new_file_src "            if (!resetN) data_reg <= ’{default:0};"
puts $new_file_src "            else         data_reg <= data_packet;"
puts $new_file_src "    endmodule"
puts $new_file_src "    // ADVANTAGE: 4 lines of code in SystemVerilog replaces 216 lines of old Verilog – and ensures consistency in all 4 places!"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    interface chip_bus      // SystemVerilog interfaces are a compound, multi-signal port"
puts $new_file_src "                            // Bundles any number of signals (nets and variables) together"
puts $new_file_src "                            // Bundles “methods” (tasks and functions) with the signals"
puts $new_file_src "                            // Bundles assertion checks with the signals;"
puts $new_file_src "        logic \[31:0] data, address;"
puts $new_file_src "        logic request, grant,"
puts $new_file_src "        boolean_t ready;"
puts $new_file_src "    endinterface"
puts $new_file_src "    module CPU (chip_bus bus,"
puts $new_file_src "        input logic clk,"
puts $new_file_src "        input logic reset);"
puts $new_file_src "        ..."
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    always_comb     // special hardware-oriented procedures documenting engineer's intent"
puts $new_file_src "    always_comb     // always_comb automatically executes once at time zero, always_comb is sensitive to changes within the contents of a function, Variables on the left-hand side of assignments within an always_comb procedure, including variables from the contents of a called function, cannot be written to by any other processes"
puts $new_file_src "        if (!mode)"
puts $new_file_src "            o1 = a + b;"
puts $new_file_src "        else"
puts $new_file_src "            o2 = a - b;"
puts $new_file_src "    always_ff           // Sequential Flip-Flop logic: it can contain one and only one event control and no blocking timing controls"
puts $new_file_src "    always_latch        // used to model latch logic. It has identical rules to always_comb, and the SystemVerilog LRM recommends software tools perform additional checks to ensure code within the procedure models latch behaviour."
puts $new_file_src "    // ADVANTAGE: RTL code intent is self-documented"
puts $new_file_src "                  Non-synthesizable code won’t simulate"
puts $new_file_src "                  Simulation, synthesis and formal tools use same rules"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    assign mywire = a & b"
puts $new_file_src "    always_comb mywire = a & b"
puts $new_file_src "    always_ff @(posedge clk)"
puts $new_file_src "        r <= r+1;"
puts $new_file_src "    always_ff @(posedge clk or posedge rst)"
puts $new_file_src "        if(reset)"
puts $new_file_src "            r <= 0;"
puts $new_file_src "        else"
puts $new_file_src "            r <= r + 1;"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    The 'case() inside' statement:"
puts $new_file_src "    case (opcode) inside"
puts $new_file_src "        8’b1???????: ... // only compare most significant bit"
puts $new_file_src "        8’b????1111: ... // compare lower 4 bits, ignore upper bits"
puts $new_file_src "        ..."
puts $new_file_src "        default: \$error(\"bad opcode\");"
puts $new_file_src "    endcase"
puts $new_file_src "    ADVANTAGE: case() inside eliminates the serious GOTCHA of casex and casez than could lead to design bugs going undetected"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    // 'unique', 'unique0' and 'priority': Synthesis pragmas: enable 'parallel_case' and/or 'full_case' synthesis pragmas"
puts $new_file_src "    always_comb"
puts $new_file_src "        unique case (state) // Simulation warnings if state matches multiple branches (not a valid parallel_case)"
puts $new_file_src "            RDY: ...        // Simulation warnings if state doesn’t match any branch (not a valid full_case)"
puts $new_file_src "            SET: ..."
puts $new_file_src "            GO : ..."
puts $new_file_src "        endcase"
puts $new_file_src "    ADVANTAGE: Automatic run-time checking that the decision statement will synthesize as intended"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    always_ff @(posedge clk)"
puts $new_file_src "        if(add1 && add2) r <= r + 3;"
puts $new_file_src "        else if(add2) r <= r + 2;"
puts $new_file_src "        else if(add1) r <= r + 1;"
puts $new_file_src "    always_ff @(posedge clk)"
puts $new_file_src "        case({add2, add1})"
puts $new_file_src "            2'b11   : r <= r + 3;"
puts $new_file_src "            2'b10   : r <= r + 2;"
puts $new_file_src "            2'b01   : r <= r + 1;"
puts $new_file_src "            default : r <= r;"
puts $new_file_src "        endcase"
puts $new_file_src "    always_ff @(posedge clk)"
puts $new_file_src "        r <= (add1 && add2) ? r + 3 :"
puts $new_file_src "                       add2 ? r + 2 :"
puts $new_file_src "                       add1 ? r + 1 : r;"
puts $new_file_src "    always_ff @(posedge clk)"
puts $new_file_src "        r <= r + {add2, add1};"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    module simple_clocked_alu_systemverilog("
puts $new_file_src "            input      clk,"
puts $new_file_src "            input      \[1:0] func,"
puts $new_file_src "            input      \[3:0] a, b,"
puts $new_file_src "            output reg \[3:0] result"
puts $new_file_src "        );"
puts $new_file_src "        always_ff @(posedge clk)"
puts $new_file_src "            case(func)"
puts $new_file_src "                2'd0    : result <= a + b;"
puts $new_file_src "                2'd1    : result <= a - b;"
puts $new_file_src "                2'd2    : result <= a & b;"
puts $new_file_src "                default : result <= a ^ b;"
puts $new_file_src "            endcase"
puts $new_file_src "    endmodule"
puts $new_file_src "    module simple_clocked_alu_pre2001verilog("
puts $new_file_src "            clk,"
puts $new_file_src "            func,"
puts $new_file_src "            a,"
puts $new_file_src "            b,"
puts $new_file_src "            result"
puts $new_file_src "        );"
puts $new_file_src "        input  clock;"
puts $new_file_src "        input  \[1:0] func;"
puts $new_file_src "        input  \[3:0] a,b;"
puts $new_file_src "        output \[3:0] result;"
puts $new_file_src "        reg    \[3:0] result;"
puts $new_file_src "        always_ff @(posedge clk)"
puts $new_file_src "            case(func)"
puts $new_file_src "                2'd0    : result <= a + b;"
puts $new_file_src "                2'd1    : result <= a - b;"
puts $new_file_src "                2'd2    : result <= a & b;"
puts $new_file_src "                default : result <= a ^ b;"
puts $new_file_src "            endcase"
puts $new_file_src "    endmodule"
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    "
puts $new_file_src "    wire clock_here"
puts $new_file_src "    wire \[3:0] data0_here, data1_here, sum_here;"
puts $new_file_src "    inst_simple_clocked_alu simple_clocked_alu("
puts $new_file_src "        .clk(clock_here)"
puts $new_file_src "        .func(0),            // constant function"
puts $new_file_src "        .a(data0_here)"
puts $new_file_src "        .b(data1_here)"
puts $new_file_src "        .result(sum_here)"
puts $new_file_src "    );"
puts $new_file_src ""
puts $new_file_src ""
puts $new_file_src "    \/\/ ----------------------------"
puts $new_file_src "    \/\/ -- Declaration of Signals --"
puts $new_file_src "    \/\/ ----------------------------"
puts $new_file_src ""
puts $new_file_src "    \/\/ -----------------------"
puts $new_file_src "    \/\/ -- User Architecture --"
puts $new_file_src "    \/\/ -----------------------"
puts $new_file_src ""
puts $new_file_src "    \/\/ --------------------------------"
puts $new_file_src "    \/\/ -- Unsupported Parameters Check --"
puts $new_file_src "    \/\/ --------------------------------"
puts $new_file_src ""
puts -nonewline $new_file_src "  "